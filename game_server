#!/usr/bin/env ruby

require 'optparse'
require 'rubygems'
require 'ffi-rzmq'

require './the2048game'


def run(port=nil)
  # runs the game

  # select a random port if none is set
  port = Array(6000...7000).sample if port.nil?

  # socket for communication
  context = ZMQ::Context.new(1)
  socket = context.socket(ZMQ::REQ)
  socket.bind("tcp://*:#{port}")

  # create the board
  board = The2048Game::Board.new socket: nil

  # define the error hash
  errors = { error: "Bad request '#{request}', try #{The2048Game::DIRECTIONS.join(', ')}" }

  # we need a place to store the and the reply
  reply = ''
  tries = 0

  def communicate
    # handles the communication between the client and the server
    # this function obfuscates some of the logic, so please take a closer look at it

    # send the board
    board_hash = board.hash
    board_hash = board_hash.update(errors.update({tries: tries})) if tries > 0
    socket.send_string board_hash.to_yaml

    # increase the counter of tries
    tries += 1

    # get 
    socket.recv_string reply
  end

  while true
    # send the current status of the board to the client
    communicate until (board.directions + ['exit']).include? reply

    # exit if requested
    break if reply.eql? 'exit'

    # move the fields in the requested direction
    board.move! reply

    # check if the game is over and start a new one if needed
    board = The2048Game::Board.new if board.game_over?

    # reset the number of tries
    tries = 0
  end

  # cleanly close the socket
  socket.close
end


if __FILE__ == $0

  # parse the program options
  options = { :port => 5555 }
  OptionParser.new do |opts|
    # the program banner
    opts.banner = "Usage: player.rb [options]"

    # the program options
    opts.on('-p', '--port PORT', 'Server port') { |v| options[:port] = v}

    # the help option
    opts.on('-h', '--help', 'Print this help') do
      puts opts
      exit
    end
  end.parse!

  # run the game listening on the given port
  run(options[:port])
end
